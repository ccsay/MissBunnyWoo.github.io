
<h1 id="golang学习笔记之4链表实现">Golang学习笔记之4:链表实现</h1>
<p>以前学数据结构的时候，总觉得很抽象，把他想象的很高端，以为是特定算法，需要去记忆！做过几年开发后，再学习golang语言，想去重温下链表二叉树这些数据结构，原来这么多年，都是被名次说法给困扰了。其实，算法，或者数据结构（链表，树，图）其实就是一种分析问题的思路，我们如果把分析的思路转化为自己理解的方式来结合写代码，就会觉得不是那么抽象了。</p>

<p><code class="highlighter-rouge">分析思路：</code></p>
<ol>
  <li>结构体，是一个对象的描述信息！结构体可以封装我们任何描述的字段！
     2. 那么链表？肯定要存储数值，那么就要有data
     3. 两个节点元素之间要建立关系，所以我们使用了指针来🔗连接一个个节点，组成一个链条🔗🔗🔗
     4. 这样就把学术说法转化成自己代码实际的内容
     5. 往链表中插入数据，就是给结构体中指针变量赋值</li>
</ol>

<h3 id="定义结构体">定义结构体</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>
//单向链表节点的结构体类型
type LinkNode struct {
	data interface{}
	next *LinkNode
}

//链表的结构体
type Link struct {
	head *LinkNode
	tail *LinkNode
}

</code></pre>
</div>

<h3 id="插入元素头插法">插入元素（头插法）</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>//头部插入，移动头部指针
func (p *Link) InsertHead(data interface{}) {
	//每次插入的数据封装为一个节点
	node := &amp;LinkNode{
		data: data,
		next: nil,
	}
	//空链表判断，头尾指针直接指向唯一的元素
	if p.head == nil &amp;&amp; p.tail == nil {
		p.head, p.tail = node, node
		return
	}
	//不为空的链表，就移动头部指针
	node.next = p.head
	p.head = node

}
</code></pre>
</div>

<h3 id="插入元素尾插法">插入元素（尾插法）</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>
//尾部插入，移动尾部指针
func (p *Link) InsertTail(data interface{}) {
	//每次插入的数据封装为一个节点
	node := &amp;LinkNode{
		data: data,
		next: nil,
	}
	//空链表判断，头尾指针直接指向唯一的元素
	if p.head == nil &amp;&amp; p.tail == nil {
		p.head = node
		p.tail = node
		return
	}

	//不为空的链表，就移动尾部指针
	p.tail.next = node
	p.tail = node

}
</code></pre>
</div>

<h3 id="遍历链表">遍历链表</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>
//链表的遍历
func (p Link) Traverse() {
	for p.head != nil { //当节点不为nil时，就遍历输出
		fmt.Println(p.head.data)
		p.head = p.head.next //移动头部指针
	}
}
</code></pre>
</div>

<h3 id="删除">删除</h3>
<blockquote>

  <p>结构体默认传递是值传递(因为不想使遍历后，改变原链表，所以使用值传递)
想删除，可以使用一个指针节点类型的，来变更指针next
临时节点，因为是单向链表，用临时节点，存放要删除元素的前一个节点</p>

</blockquote>

<p>代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func (p Link) Remove(e interface{}) {
	temp := p.head //让临时节点指向，存放要删除元素的前一个节点

	for p.head != nil { //从头开始循环遍历，直到节点为空，停止遍历
		if p.head.data == e {
			temp.next = temp.next.next //找到，则利用暂存的temp节点，使指针指向该元素节点的下一个节点
		}

		temp = p.head        //temp存放前一个节点
		p.head = p.head.next //p用来做遍历使用

	}
}
</code></pre>
</div>
<h3 id="测试main函数">测试main函数</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>func main() {
	linkData := new(Link)
	for i := 0; i &lt; 10; i++ {
		linkData.InsertTail(i) //尾部插入是正序的

	}
	linkData.Traverse()
	for i := 0; i &lt; 10; i++ {
		linkData.InsertHead(i) //头部插入是逆序的

	}
	linkData.Traverse()
	//删除值为8的节点
	linkData.Remove(8)
	fmt.Println("删除后")
	linkData.Traverse()
}

</code></pre>
</div>

