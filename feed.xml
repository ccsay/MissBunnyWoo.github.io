<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序媛博客</title>
    <description>兔姐🐰，一枚有信仰的程序媛，专注学习技术，热衷于知识分享，为开源贡献出一点点力量！</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 06 May 2018 00:21:51 +0800</pubDate>
    <lastBuildDate>Sun, 06 May 2018 00:21:51 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>星云链DAPP开发文档集合</title>
        <description>&lt;h1 id=&quot;星云链dapp开发文档集合&quot;&gt;星云链DAPP开发文档集合&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1OTQ3MTI3Ng==&amp;amp;mid=2247483769&amp;amp;idx=1&amp;amp;sn=3bd33271ad651779a4f6c96455c2a52a&amp;amp;chksm=fc178ebacb6007acd3d2505164fc1b75df12f357792b41703e66d6d33c98bf700f896e8f0d3a&amp;amp;scene=21#wechat_redirect&quot;&gt;这张船票你不能错过，3200万奖金的DApp开发激励计划&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注册地址：&lt;/p&gt;

&lt;p&gt;https://incentive.nebulas.io/cn/signup.html?invite=VFRNt&lt;/p&gt;

&lt;p&gt;官网：&lt;/p&gt;

&lt;p&gt;https://nebulas.io&lt;/p&gt;

&lt;p&gt;官方Wiki：&lt;/p&gt;

&lt;p&gt;https://github.com/nebulasio/wiki/wiki&lt;/p&gt;

&lt;p&gt;官方教程：&lt;/p&gt;

&lt;p&gt;https://github.com/nebulasio/wiki/blob/master/tutorials.md&lt;/p&gt;

&lt;p&gt;手把手教你开发DApp：&lt;/p&gt;

&lt;p&gt;https://mp.weixin.qq.com/s/Bhez3UOjZA3JfmJoZV2iJA&lt;/p&gt;

&lt;p&gt;网页钱包：&lt;/p&gt;

&lt;p&gt;https://github.com/nebulasio/web-wallet&lt;/p&gt;

&lt;p&gt;Web SDK：&lt;/p&gt;

&lt;p&gt;https://github.com/nebulasio/neb.js&lt;/p&gt;

&lt;p&gt;区块浏览器：&lt;/p&gt;

&lt;p&gt;https://explorer.nebulas.io&lt;/p&gt;

&lt;p&gt;NAS测试币：&lt;/p&gt;

&lt;p&gt;https://testnet.nebulas.io/claim/&lt;/p&gt;

&lt;p&gt;星云激励计划细则：&lt;/p&gt;

&lt;p&gt;https://nebulas.io/cn/incentive_spec.html&lt;/p&gt;

&lt;p&gt;星云激励计划Q&amp;amp;A：&lt;/p&gt;

&lt;p&gt;https://mp.weixin.qq.com/s/UZaL-pHG4CfGxEWc97UcRw&lt;/p&gt;

&lt;p&gt;非技术白皮书：&lt;/p&gt;

&lt;p&gt;https://nebulas.io/docs/NebulasWhitepaperZh.pdf&lt;/p&gt;

&lt;p&gt;技术白皮书：&lt;/p&gt;

&lt;p&gt;https://nebulas.io/docs/NebulasTechnicalWhitepaperZh.pdf&lt;/p&gt;

&lt;p&gt;Wiki：&lt;/p&gt;

&lt;p&gt;https://github.com/nebulasio/wiki&lt;/p&gt;

&lt;p&gt;Tutorials：&lt;/p&gt;

&lt;p&gt;https://github.com/nebulasio/wiki/tree/master/tutorials&lt;/p&gt;

&lt;p&gt;DappReview - 国内最大的DApp排行榜&lt;/p&gt;

&lt;p&gt;给星云激励计划开发者提供以下支持：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;推广奖励全额返还&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DApp排行上线，增加访问和用户&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DappReview公众号报道+专访&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下游钱包对接应用商店&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*以上支持全部免费，细节请看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1OTQ3MTI3Ng==&amp;amp;mid=2247483769&amp;amp;idx=1&amp;amp;sn=3bd33271ad651779a4f6c96455c2a52a&amp;amp;chksm=fc178ebacb6007acd3d2505164fc1b75df12f357792b41703e66d6d33c98bf700f896e8f0d3a&amp;amp;scene=21#wechat_redirect&quot;&gt;这张船票你不能错过，3200万奖金的DApp开发激励计划&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/06/golang-dapp/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/06/golang-dapp/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>Golang学习笔记之4: 链表实现</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;整理：程序媛🐰&lt;/p&gt;

  &lt;p&gt;博客：http://cxytujie.github.io&lt;/p&gt;

  &lt;p&gt;备注：如有错误，请指正，不断更新迭代&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;以前学数据结构的时候，总觉得很抽象，把他想象的很高端，以为是特定算法，需要去记忆！做过几年开发后，再学习golang语言，想去重温下链表二叉树这些数据结构，原来这么多年，都是被名次说法给困扰了。其实，算法，或者数据结构（链表，树，图）其实就是一种分析问题的思路，我们如果把分析的思路转化为自己理解的方式来结合写代码，就会觉得不是那么抽象了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;分析思路：&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;结构体，是一个对象的描述信息！结构体可以封装我们任何描述的字段！
     2. 那么链表？肯定要存储数值，那么就要有data
     3. 两个节点元素之间要建立关系，所以我们使用了指针来🔗连接一个个节点，组成一个链条🔗🔗🔗
     4. 这样就把学术说法转化成自己代码实际的内容
     5. 往链表中插入数据，就是给结构体中指针变量赋值&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;定义结构体&quot;&gt;定义结构体&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//单向链表节点的结构体类型
type LinkNode struct {
	data interface{}
	next *LinkNode
}

//链表的结构体
type Link struct {
	head *LinkNode
	tail *LinkNode
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;插入元素头插法&quot;&gt;插入元素（头插法）&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//头部插入，移动头部指针
func (p *Link) InsertHead(data interface{}) {
	//每次插入的数据封装为一个节点
	node := &amp;amp;LinkNode{
		data: data,
		next: nil,
	}
	//空链表判断，头尾指针直接指向唯一的元素
	if p.head == nil &amp;amp;&amp;amp; p.tail == nil {
		p.head, p.tail = node, node
		return
	}
	//不为空的链表，就移动头部指针
	node.next = p.head
	p.head = node

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;插入元素尾插法&quot;&gt;插入元素（尾插法）&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//尾部插入，移动尾部指针
func (p *Link) InsertTail(data interface{}) {
	//每次插入的数据封装为一个节点
	node := &amp;amp;LinkNode{
		data: data,
		next: nil,
	}
	//空链表判断，头尾指针直接指向唯一的元素
	if p.head == nil &amp;amp;&amp;amp; p.tail == nil {
		p.head = node
		p.tail = node
		return
	}

	//不为空的链表，就移动尾部指针
	p.tail.next = node
	p.tail = node

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;遍历链表&quot;&gt;遍历链表&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//链表的遍历
func (p Link) Traverse() {
	for p.head != nil { //当节点不为nil时，就遍历输出
		fmt.Println(p.head.data)
		p.head = p.head.next //移动头部指针
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;
&lt;blockquote&gt;

  &lt;p&gt;结构体默认传递是值传递(因为不想使遍历后，改变原链表，所以使用值传递)
想删除，可以使用一个指针节点类型的，来变更指针next
临时节点，因为是单向链表，用临时节点，存放要删除元素的前一个节点&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (p Link) Remove(e interface{}) {
	temp := p.head //让临时节点指向，存放要删除元素的前一个节点

	for p.head != nil { //从头开始循环遍历，直到节点为空，停止遍历
		if p.head.data == e {
			temp.next = temp.next.next //找到，则利用暂存的temp节点，使指针指向该元素节点的下一个节点
		}

		temp = p.head        //temp存放前一个节点
		p.head = p.head.next //p用来做遍历使用

	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;测试main函数&quot;&gt;测试main函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
	linkData := new(Link)
	for i := 0; i &amp;lt; 10; i++ {
		linkData.InsertTail(i) //尾部插入是正序的

	}
	linkData.Traverse()
	for i := 0; i &amp;lt; 10; i++ {
		linkData.InsertHead(i) //头部插入是逆序的

	}
	linkData.Traverse()
	//删除值为8的节点
	linkData.Remove(8)
	fmt.Println(&quot;删除后&quot;)
	linkData.Traverse()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 05 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/05/golang-lianbiao/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/05/golang-lianbiao/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>Golang学习笔记之3：结构体、面向对象思想</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;整理：程序媛🐰&lt;/p&gt;

  &lt;p&gt;博客：http://cxytujie.github.io&lt;/p&gt;

  &lt;p&gt;备注：如有错误，请指正，不断更新迭代&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;面向对象&quot;&gt;面向对象：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;面向对象：不是一门语言，也不是一门技术，是一种编程思路，把每一步封装成函数，然后调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;面向过程：只关心过程、步骤，只关注实现的过程，像一个计划表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;思考方式&quot;&gt;思考方式：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;考虑问题中有哪些对象（类）？&lt;/li&gt;
  &lt;li&gt;这些对象是啥？属性————&amp;gt;字段，行为————&amp;gt;方法(函数)&lt;/li&gt;
  &lt;li&gt;对象和对象的关系（类和类的关系）？是否包含？是否聚合？&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;类&quot;&gt;类&lt;/h3&gt;
&lt;p&gt;类：同一类事物的抽象描述，类中包含两种：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;静态属性：就是描述性字段&lt;/li&gt;
  &lt;li&gt;动态属性：方法，即函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;对象&quot;&gt;对象&lt;/h3&gt;
&lt;p&gt;对象：类中的一个具体的实例，使用类创建出来的就是对象&lt;/p&gt;

&lt;h3 id=&quot;类和对象关系&quot;&gt;类和对象关系&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;类是对象的抽象描述，对象是类的一个具体实例&lt;/li&gt;
  &lt;li&gt;将一类对象的共同特征，进行抽取————&amp;gt;定义类
    抽象出： class —-&amp;gt;struct{
             属性：字段，变量
             行为：方法，函数
                 }&lt;/li&gt;
  &lt;li&gt;将类进行实例化————&amp;gt;创建对象
         通过struct创建对象，p1:=Person{}
         对象名.属性
         对象名.方法名（）
         直接调用的是函数
         通过对象调用的是方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;面向对象三大特征&quot;&gt;面向对象三大特征&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 封装性
		&quot;打包&quot;，函数，方法，结构体，对外留个口，不关系你里面是细节，只需要调用即可，不关心内部的逻辑细节
2. 继承性
		描述一个类和另一个类的关系
		
	    子类继承父类：
		子类可以直接访问父类的属性和方法
		子类可以新增自己的属性和方法
		子类可以重写父类的方法
		
		靠结构体的嵌套：
		匿名结构体字段：提升字段（子类里爹的字段，就是提升字段）
		
3. 多态性：接口,一类事物的多种形态
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;结构体&quot;&gt;结构体&lt;/h2&gt;
&lt;h3 id=&quot;定义语法&quot;&gt;定义语法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type 结构体名  struct{
				字段名   字段类型
			}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;创建对象&quot;&gt;创建对象&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;对象名：=结构体名{val1，val2，val3}&lt;/li&gt;
  &lt;li&gt;对象名:=结构体名{字段名：val1,字段名：val2}&lt;/li&gt;
  &lt;li&gt;对象名：=结构体名{}
 对象名.字段名，进行赋值和取值&lt;/li&gt;
  &lt;li&gt;对象名：=new（Type）	//创建一个指针&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;结构体参数类型&quot;&gt;结构体参数类型&lt;/h3&gt;
&lt;p&gt;func fun1(P Person){ } //拷贝数值，默认传递是值类型传递
func fun2(p *Person){ } //指针地址传递&lt;/p&gt;

&lt;h3 id=&quot;深浅拷贝&quot;&gt;深浅拷贝&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;深拷贝：就是将值复制一份，改变此处的值不影响原来的值&lt;/li&gt;
  &lt;li&gt;浅拷贝：将地址赋值个另一个变量，当一处对此地址进行改变时，远来的变量的值也变换了&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;匿名结构体和匿名字段&quot;&gt;匿名结构体和匿名字段&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;没有名字的结构体
			a:=struct{字段的定义}{赋值}
			func (){}()
			匿名字段
			type A struct{
				string
				int
			}
			b:=A{&quot;字符串&quot;,23}
			b.string,b.int
匿名字段可以理解为字段名和字段类型一致
	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;类和类的关系结构体嵌套&quot;&gt;类和类的关系：（结构体嵌套）&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		1、聚合关系（has a ）：讲一个类作为另一个类的属性字段

		2、继承性(is a )：(嵌套)描述两个类的关系，一个类作为另一个类的子类，子类可以使用父类的功能
		继承的意义：
		1. 避免重复代码（子类）
		2. 扩展类的功能（父类）
		子类 is a 父类（能说的通就可以使用继承）
		go语言没有真正的继承，靠两个结构体的嵌套模拟
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;

&lt;p&gt;通过面向对象的思维方式设计程序三步走：
			1. 创建struct结构体
			2. 设计结构体的功能方法
			3. 创建结构体对象&lt;/p&gt;

&lt;h3 id=&quot;代码示例聚合继承&quot;&gt;代码示例（聚合、继承）&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
)

type A struct {
	name string
	age  int
}

type B struct {
	a A    //模拟聚合
}

type C struct {
	A  //模拟继承		有提升字段
}

func main() {
	//b:=B{}
	b := B{A{&quot;Jack&quot;, 20}}          //多层嵌套结构体初始化
	fmt.Println(b.a.name, b.a.age) //输出Jack 20
	c := C{A{&quot;Bob&quot;, 18}}
	//匿名提升字段可以通过结构体的名字进行访问
	fmt.Println(c.A.name, c.A.age) //输出Bob 18
	//匿名提升字段也可以直接访问其字段
	fmt.Println(c.name, c.age)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 03 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/03/golang-struct/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/03/golang-struct/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>Golang学习笔记之2：多种排序算法</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;整理：程序媛🐰&lt;/p&gt;

  &lt;p&gt;博客：http://cxytujie.github.io&lt;/p&gt;

  &lt;p&gt;备注：如有错误，请指正，不断更新迭代&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h3&gt;
&lt;p&gt;冒泡排序思想：从前到后，依次两两比较，两层循环，一层控制比较趟数，一层控制前后&lt;code class=&quot;highlighter-rouge&quot;&gt;两两比较&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func sortByBubble(s []int64) {
	for i := 0; i &amp;lt; len(s); i++ { //i控制比较趟数
		for j := 0; j &amp;lt; len(s)-i-1; j++ { //j控制从前到后，两两比较
			if s[j] &amp;gt; s[j+1] { //两两比较
				s[j], s[j+1] = s[j+1], s[j]
			}
		}
	}
	fmt.Println(s)

}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;选择排序&lt;/h3&gt;
&lt;p&gt;选择排序思想：假定位前面是即将要存有序的位置，后面是无序的位置。从没有排序的序列中，选择一个最小的，依次插入到前面的有序位置的后边。
` 从乱序中找到目标 `&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//选择排序：假定位前面是即将要存有序的位置，后面是无序的位置。从没有排序的序列中，选择一个最小的，依次插入到前面的有序位置的后边
func sortBySelect(s []int64) {
	for i := 0; i &amp;lt; len(s); i++ { //控制比较的趟数,守住不动的定点
		for j := i + 1; j &amp;lt; len(s); j++ { //从后面挑选最小的
			if s[i] &amp;gt; s[j] { //拿定点，跟后面的比较，最小的就交换位置
				s[i], s[j] = s[j], s[i]
			}
		}
	}
	fmt.Println(s)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;插入排序&quot;&gt;插入排序&lt;/h3&gt;
&lt;p&gt;插入排序思想：从后面乱序中，依次取出一个然后插入到前面排序的位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//插入排序：从后面乱序中，依次取出一个然后插入到前面排序的位置，
func sortByInsert(s []int64) {
	for i := 1; i &amp;lt; len(s); i++ { //i控制后面乱序和前面顺序的分界点，i控制分界点的移动
		if s[i-1] &amp;gt; s[i] { //判断相邻的位置是否大小顺序正确，否则就要找到正确的位置
			for j := i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; s[j] &amp;gt; s[j+1]; j-- { //j控制位置的移动
				s[j+1], s[j] = s[j], s[j+1] //以交换的方式做了简单的数据移动
			}
		}
	}
	fmt.Println(s)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;快速排序&quot;&gt;快速排序&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;排序算法主要思路：&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;假定起始位置位哨兵&lt;/li&gt;
    &lt;li&gt;写一个方法，作用用来确定中介的位置，并且进行同时的排序功能，返回中介的位置&lt;/li&gt;
    &lt;li&gt;递归方式分别调用比中介点小的部分，和比中介点大的部分，一分为二的思想&lt;/li&gt;
    &lt;li&gt;在求中介值时，始终明确low&amp;lt;high，使用一个temp变量存储哨兵的值&lt;/li&gt;
    &lt;li&gt;从后往前，逐个遍历比较，遇到小于哨兵的就暂停，且进行交换&lt;/li&gt;
    &lt;li&gt;从前往后，逐个遍历比较，遇到大于哨兵的就暂停，且进行交换&lt;/li&gt;
    &lt;li&gt;直到low和high相遇，停止循环，返回low的位置，即下次的一分为二时使用的分界点&lt;/li&gt;
  &lt;/ol&gt;

&lt;/blockquote&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//快速排序：
func quickSort(s []int64, low, high int64) { //start起始点，end终止点
	if low &amp;lt; high {
		flag := partition(s, low, high) //把切片一分为二，分别对两部分进行递归排序
		quickSort(s, low, flag-1)       //低的部分进行排序
		quickSort(s, flag+1, high)      //高的部分进行排序
	}

}



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func partition(s []int64, low, high int64) int64 {
	//分别控制两个点，一个从前往后遍历，一个从后往前遍历
	//假设我们每次将序列中的第一个元素作为定位排序的目标
	tempValue := s[low] //哨兵
	for low &amp;lt; high { //当两边相遇时，结束本趟比较，直到low和high相遇时本趟排序结束
		for s[high] &amp;gt; tempValue &amp;amp;&amp;amp; low &amp;lt; high { //从后往前遍历，找比哨兵小的数
			high--
		}
		tempValue, s[high] = s[high], tempValue //遇到比哨兵小的数则暂停，进行交换

		for s[low] &amp;lt; tempValue &amp;amp;&amp;amp; low &amp;lt; high { //然后，从前往后遍历，找比哨兵大的数
			low++
		}
		s[low], tempValue = tempValue, s[low] //遇到比哨兵大的，就暂停，进行交换
		fmt.Println(s)
	}

	return low //返回本次排序的能够确定最终位置的元素位置
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试使用的main函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
	s := []int64{6, 1, 11, 2, 7, 9, 3, 4, 5, 10, 8}
	fmt.Println(s)
	sortByBubble(s)
	sortBySelect(s)
	sortByInsert(s)
	quickSort(s, 0, int64(len(s)-1))
	fmt.Println(s)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 03 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/03/golang-sort/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/03/golang-sort/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>Golang学习笔记之1：数组、切片、map内存原理</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;整理：程序媛🐰&lt;/p&gt;

  &lt;p&gt;博客：http://cxytujie.github.io&lt;/p&gt;

  &lt;p&gt;备注：如有错误，请指正，不断更新迭代&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;1数组&quot;&gt;1数组：&lt;/h3&gt;
&lt;p&gt;在内存中开辟一块连续的存储地址&lt;/p&gt;

&lt;h4 id=&quot;11特点&quot;&gt;1.1特点：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;有序、可重复、数据类型一致&lt;/li&gt;
  &lt;li&gt;定长：数组一旦创建长度，不能更改长度大小，但是可以修改其存储的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;12数组语法&quot;&gt;1.2数组语法：&lt;/h4&gt;

&lt;h4 id=&quot;13-定义数组方式&quot;&gt;1.3 定义数组方式&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr [10] int               //默认为0。0。0。0。
var arr1=[10] int {1,2,3,4,5,6}       //值为1,2,3,4,5,6 ，0，0，0，0，
arr2:=[10] int {1,2,3,4,5,6}      //推导类型
arr3:=[...] int {1,2,3,4,5,6}     //长度为实际存储的长度
arr4:=[...] int {1:9,10:3}       //指定下标位置赋值

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;14-数组存取方式&quot;&gt;1.4 数组存取方式&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr[2]=5

//数组是值传递，是将此数组的值拷贝了一份，赋给其他变量数组
temp:=[10] int {}
temp=arr
temp[0]=99    //temp的赋值不影响原数组的值

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;15-数组的循环操作---range方式&quot;&gt;1.5 数组的循环操作   range方式&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for index,value:=range arr{
fmt.Println(index) //数组下标
fmt.Println(value) //数组元素值
}

//数组len(),cap()，数组的长度和容量一致的。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-切片&quot;&gt;2 切片：&lt;/h3&gt;
&lt;p&gt;在内存中开辟一块连续的存储地址,长度不固定&lt;/p&gt;

&lt;h4 id=&quot;21-切片特点&quot;&gt;2.1 切片特点：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;变长：长度和容量都可以更改&lt;/li&gt;
  &lt;li&gt;引用类型（操作的是指针）&lt;/li&gt;
  &lt;li&gt;有序&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;22-创建切片&quot;&gt;2.2 创建切片：&lt;/h4&gt;

&lt;p&gt;#####2.2.1 定义切片的方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var slice [] int //不写空间大小 ,len=0,cap=0     暂时还没有开辟空间 ，不能够操作赋值的情况
fmt.Println(slice, len(slice), cap(slice))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;222-特别注意&quot;&gt;2.2.2 特别注意：&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slice[0]=1 //暂时还没有开辟空间 ，不能够操作赋值的情况，会提示数组越界错误
slice[1]=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;223-make方式开辟切片空间&quot;&gt;2.2.3 make方式开辟切片空间&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//make方式开辟空间，make([]类型，长度，容量)
slice = make([]int, 5, 10) //开辟切片空间后，才可以进行赋值操作
slice[0] = 1               //
slice[1] = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;224-定义切片时直接初始化&quot;&gt;2.2.4 定义切片时，直接初始化&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slice2 := []int{1, 2, 3, 45, 6}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;225-基于数组的基础上创建切片&quot;&gt;2.2.5 基于数组的基础上创建切片&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr6 := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
slice3 := arr6[2:7]
fmt.Println(arr6)                     //[1 2 3 4 5 6 7 8 9 10]
fmt.Println(slice3)                   //[3 4 5 6 7]
fmt.Println(len(slice3), cap(slice3)) //len=5  cap=8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;23切片内存原理非常重要&quot;&gt;2.3切片内存原理（非常重要）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slice3[0] = 100 //切片的下标以自身为准，从0开始  赋值操作时注意不要超过切片的下标index值

//修改基于数组的切片，数组大小空间范围内，修改切片时，原数组的值也相应变化

fmt.Println(arr6)   //[1 2 100 4 5 6 7 8 9 10]
fmt.Println(slice3) //[100 4 5 6 7]

//当切片超过len,但是小于cap的操作
//切片通过append方式增加长度

slice3 = append(slice3, 88888) //切片追加元素，但是因为切片此时的指针定位，还在切片cap范围内，所以，不需要另外拷贝数据分配新地址空间，所以原数组受影响
fmt.Println(arr6)              //[1 2 100 4 5 6 7 88888 9 10]
fmt.Println(slice3)            //[100 4 5 6 7 88888]

//当超过cap时，拷贝数据到新的地址空间，此时不影响原数组
slice3 = append(slice3, 99, 99, 99, 99, 99, 99, 99, 99)
fmt.Println(arr6)   //[1 2 100 4 5 6 7 88888 9 10]
fmt.Println(slice3) //[100 4 5 6 7 88888 99 99 99 99 99 99 99 99]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3-map集合映射&quot;&gt;3 Map集合（映射）：&lt;/h3&gt;

&lt;h4 id=&quot;31特点&quot;&gt;3.1特点：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;存储无序的键值对&lt;/li&gt;
  &lt;li&gt;键值对一一对应&lt;/li&gt;
  &lt;li&gt;键不能重复，重复了就覆盖&lt;/li&gt;
  &lt;li&gt;无序&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;32-创建map&quot;&gt;3.2 创建map:&lt;/h4&gt;
&lt;h5 id=&quot;321-方式一&quot;&gt;3.2.1 方式一&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//方式一：定义map变量，但是未开辟存储空间，即空map  nil
var map1 map[int]string //map[]
fmt.Printf(&quot;%p&quot;, &amp;amp;map1)
map1[1] = &quot;hello&quot; //   未开辟空间时，不可以进行赋值操作
fmt.Println(map1) //panic: assignment to entry in nil map
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;322方式二&quot;&gt;3.2.2方式二&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//方式二：直接初始化方式
map2 := map[int]string{1: &quot;hello&quot;, 2: &quot;world&quot;, 3: &quot;!&quot;}
fmt.Println(map2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;323方式三&quot;&gt;3.2.3方式三&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//方式三：make开辟空间方式
map3 := make(map[int]string) //开辟空间后即可以赋值
fmt.Println(map3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;33添加元素&quot;&gt;3.3添加元素&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map3[1] = &quot;你好&quot; //添加元素
map3[2] = &quot;呀&quot;
fmt.Println(map3) //map[1:你好 2:呀]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;34删除元素&quot;&gt;3.4删除元素&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//删除map中的元素
delete(map3, 2)   //删除操作
fmt.Println(map3) //map[1:你好]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;35注意事项&quot;&gt;3.5注意事项&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取map操作，当key不存在时，会报错，可以使用ok的方式判断map键值对是否存在
value, ok := map3[1] //你好 true
fmt.Println(value, ok)
value1, ok1 := map3[5] // false
fmt.Println(value1, ok1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;36for-range-遍历map&quot;&gt;3.6For range 遍历map&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//for range方式遍历map
for key, value := range map3 { //key 键   value 值
fmt.Println(key, value) //1 你好
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 03 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/03/golang-slice-map/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/03/golang-slice-map/</guid>
        
        <category>golang</category>
        
        
      </item>
    
  </channel>
</rss>
